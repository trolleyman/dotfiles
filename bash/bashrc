(set -o igncr) 2>/dev/null && set -o igncr; # this comment is needed
# ^ For CRLF-unfriendly systems

# If we are a slurm job, don't load anything.
if [[ ! -z "${SLURM_JOB_ID}" ]]; then
	return
fi

# Source global definitions
if [ -f /etc/bashrc ]; then
	. /etc/bashrc
fi

. ~/.dotfiles/bash/env.sh

. ~/.dotfiles/bash/aliases.sh
. ~/.dotfiles/bash/completion.sh

. ~/.dotfiles/bash/prompt.sh

function check_dotfiles() (
	set -e
	pushd ~/.dotfiles 2>&1 1>/dev/null
	
	UPSTREAM=${1:-'@{u}'}
	LOCAL=$(git rev-parse @{0})
	REMOTE=$(git rev-parse "$UPSTREAM")
	BASE=$(git merge-base @{0} "$UPSTREAM")
	
	if [[ "$LOCAL" == "$REMOTE" ]]; then
		: # Up-to-date
	elif [[ "$LOCAL" == "$BASE" ]]; then
		printf "\e[93mWarning: Need to git pull ~/.dotfiles\e[0m\n"
	elif [[ "$REMOTE" == "$BASE" ]]; then
		printf "\e[93mWarning: Need to git push ~/.dotfiles\e[0m\n"
	else
		printf "\e[93mWarning: ~/.dotfiles has diverged from upstream\e[0m\n"
	fi
	
	# Do this in the background so there's no waiting -- we'll
	# get the warning next time we reload
	( git fetch --no-recurse-submodules 2>&1 1>/dev/null & ) 2>&1 1>/dev/null
	
	popd 2>&1 1>/dev/null
)

if [ -t 1 ]; then
	# Detect whether or not ~/.dotfiles is out of date
	pushd ~/.dotfiles 2>&1 >/dev/null
	if [[ -z "$( git remote -v | grep fetch | grep https:// )" ]]; then
		check_dotfiles
	fi
	popd 2>&1 >/dev/null
	
	# Info that the bashrc ran
	echo ~/.bashrc run.
fi

